# Phase 12: Programmatic Java Compilation and JAR Creation

## Overview

In this phase, we implemented the core functionality to compile Java source code generated by our CLI tool and package the resulting `.class` files into a JAR file programmatically. This completes the generation-to-package pipeline required for Daniyal ORM.

***

## What was done

- Used the Java Compiler API (`javax.tools.JavaCompiler`) to compile generated `.java` files inside the CLI tool at runtime.
- Designated a folder (`bin/classes`) to store the compiled `.class` files with package structure preserved.
- Created a method to recursively add all compiled `.class` files from the output folder into a JAR archive (`dist/pojo.jar`) using `JarOutputStream`.
- Added logic to ensure the output folders exist and old JAR files are deleted to avoid write/access conflicts.
- Incorporated cleanup of the compiled classes folder after the JAR is created to keep the project directory clean.

***

## Detailed Explanation

### Why programmatic compilation?

- Manually running `javac` complicates automation and user experience.
- Java Compiler API provides a built-in way to compile code from within Java applications.
- Enables fully automated workflows: code generation, compilation, packaging in one process.
- Essential for custom ORM frameworks that dynamically generate entity classes.

### Java Compiler API key steps

1. **Get compiler instance:**
   ```java
   JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
   ```
   Requires the application to be run with a JDK (not a JRE).

2. **Prepare file manager:**
   ```java
   StandardJavaFileManager fileManager = compiler.getStandardFileManager(null, null, null);
   ```
   Manages `.java` source and `.class` output locations.

3. **Convert `.java` files to compilation units:**
   ```java
   Iterable<? extends JavaFileObject> compilationUnits = fileManager.getJavaFileObjectsFromFiles(javaFiles);
   ```
   This wraps the physical files for the compiler.

4. **Set compilation options:**
   ```java
   List<String> options = Arrays.asList("-d", "bin/classes");
   ```
   This specifies the output directory where bytecode (`.class`) files go.

5. **Create and execute the compilation task:**
   ```java
   JavaCompiler.CompilationTask task = compiler.getTask(null, fileManager, null, options, null, compilationUnits);
   boolean success = task.call();
   ```
   Executes compilation and returns success or failure.

6. **Handle errors or proceed upon success.**

### Why specify output directory?

- Keeps compiled classes separate from sources.
- Preserves package folder hierarchy.
- Simplifies packaging and cleanup.

***

### Creating the JAR

- The compiled classes are collected under `bin/classes`.
- Open a `JarOutputStream` for the destination JAR file (`dist/pojo.jar`).
- Recursively walk the classes folder to add all `.class` files as JAR entries.
- For each class file:
  - Compute the **relative package path** inside the classes folder by removing the absolute prefix.
  - Replace OS-specific path separators (`\` on Windows) with `/` required by the JAR format.
  - Create a `JarEntry` with that relative path.
  - Write the file contents to the stream and close the entry.

- This results in a clean, properly structured JAR where Java can find classes by their package names.

***

### Clean-up and robustness

- Before JAR creation, any existing `pojo.jar` file is deleted to avoid access conflicts.
- Folders like `dist` are ensured to exist before writing files.
- After successfully creating the JAR, the intermediate compiled classes folder is deleted to keep the working directory tidy.

***

## How to use this workflow again

***

### Generalized Workflow

1. **Generate Java source files** into a known folder.
2. **Collect all source files**' `File` objects into a list.
3. **Compile programmatically** via Java Compiler API with output directory option.
4. **Package compiled files** into a JAR via `JarOutputStream`:
   - Add each class file as a `JarEntry` with relative path.
   - Write content bytes, then close entry.
5. **Delete old JAR files** before creation to prevent conflicts.
6. **Optionally clean generated `.class` files** after successful packaging.

***

### Important classes and methods to remember

- `ToolProvider.getSystemJavaCompiler()`  
- `StandardJavaFileManager` and `getJavaFileObjectsFromFiles()`  
- `JavaCompiler.CompilationTask` and `task.call()`  
- `JarOutputStream`, `JarEntry`, and recursive file adding  
- File and directory management (`File.exists()`, `mkdirs()`, `delete()`)

***

### Why this pattern matters

- Integrates seamlessly into any Java tool automating code generation and builds.
- Useful beyond ORM projects â€” e.g., compiler plugins, IDEs, automated testing setups.
- Builds your understanding of important system-level Java APIs.
- Helps write maintainable, reliable, and efficient development tools and libraries.

***